# C Plus Plus Review

## **C++第一课**-概述、输入输出、类的入门——理解封装

### **1.using namespace std;**
命名空间 ，为了避免大家共同开发的时候重名（“使用命名空间std”）。

如果用到某一个命名前面没有写**using namespace std时，也可以用std::直接调用，例如std::cout。**

### **2.头文件**：

iostream：输入输出流，用于控制台输入输出头文件。//头文件用<>,并且不用.h（使用的格式为#include<iostream>（预处理命令，将文件iostream的内容包含到该命令所在的程序文件中，文件iostream向程序提供输入和输出时需要的信息。）)

C语言中的<math.h>在C++中写作<cmath>

### **3.输入输出：**

3.1 流输入 **cin>>**  :连续输入 例如：cin>>x>>y;

3.2 流输出 **cout<<**:连续输出 例如：cout<<"字符串"<< x<<y<<endl;

* cout能够识别类型的功能表明，是可扩展的，即可重新定义<<运算符。

* cin和cout是"智能的"，可输入输出各种类型的变量，如cin>>(int型变量)>>(double型变量);

* 使用cin和cout进行输入输出的程序必须包含文件iostream,最好再增加一个using namespace std.

3.3 控制符 endl:

endl 搭配iostream对象来使用，与cout搭配使用，表示概念是重起一行，作用相当于\n（即cout<<endl;与cout<<"\n";作用相似）, 在输出流中插入endl将导致屏幕光标移到下一行开头

### **4. 类**

4.1 关于类

* C++ 中的类可以看做C语言中结构体（Struct）的升级版。（结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。）

* 类描述了一种数据类型的全部属性，而对象则是根据这些描述所创建的“实体”。

* C++中类用来自定义新的数据类型，变量，函数等。

* cout是一个ostream类对象，cin是一个istream类对象，都在iostream中定义。

4.2 格式

class：类名
{ public: //行为或属性 private: //行为或属性 };//分号一定要在，冒号不能打掉

* 类中内容分为public，private,protected三类，public和private较为常用。

* public中定义的变量其他的类名内也可以调用，private不可。

* **若未标记public或private，系统默认为private**。（struct声明的类不做private和public的声明时默认为public。）

* 只可以通过调用public后才可以调用private内容。

* 可在class外对函数重构 ，格式如下：

类名：：函数名（）{}，类似于c语言中定义函数的不同格式，仅存在格式上的差异。

 

4.3 在class外部，使用格式 ：类名+“.”+该类内部的变量名/函数名 来引用类里面的变量。（引用时无需说明函数类型，只要输入函数名称即可）

（“.”名为成员运算符）

4.4类外定义成员函数：一般类的成员函数声明都写在类的内部，函数的定义都写到外面。这样会使得类的结构看起来很整洁。

格式：类名：：函数名（  ）｛  ｝，其中" :: "称为范围解析运算符（作用域限定符或作用域运算符），声明函数属于哪个类。

 notes：如果作用域限定符::的前面无类名则其不属于任何类（全局函数，普通函数）。

4.5 尽量不要在class中对定义的变量直接赋初值，可以定义一个函数为其赋值，否则在某些编译环境下编译不通过。

4.6如果类中成员为public中的成员，则可在类声明时对其初始化，如果是private中成员，则不可在类声明时对其初始化。

4.7 在主函数建立对象时，可以直接写：类名 对象名.参数名(大小)

4.8 

1）封装（Encapsulation）

A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。

B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

备注：有2层含义（把属性和方法进行封装 对属性和方法进行访问控制）

 C++中类的封装：

成员变量，C++中用于表示类属性的变量

成员函数，C++中用于表示类行为的函数

2）类成员的访问控制

在C++中可以给成员变量和成员函数定义访问级别

Public修饰成员变量和成员函数可以在类的内部和类的外部被访问

Private修饰成员变量和成员函数只能在类的内部被访问

//类是把属性和方法封装 同时对信息进行访问控制

//类的内部，类的外部

//我们抽象了一个类，用类去定义对象

//类是一个数据类型，类是抽象的。

//对象是一个具体的变量，占用内存空间。

3）struct和class关键字区别

在用struct定义类时，所有成员的默认属性为public

在用class定义类时，所有成员的默认属性为private 

### **5 构造函数：**用于初始化类里面的变量

5.1 格式方面应注意：

   **i）构造函数和类名一致。**

   **ii) 前面不加任何返回值类型，void也不加。**

   **iii)不需要return语句**。构造函数没有返回值，因为没有变量来接收，这意味着，构造函数函数名前面不能出现返回值类型，void 也不行，函数体内也不能return某个值。

5.2 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成；

* 如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，没有形参，也不执行任何操作。

5.3 构造函数必须是public 属性（外部接口）的，否则创建对象时无法调用。当然设置为private（内部属性），protected 属性也不会报错，但是没有意义。

5.4 构造函数的初始化 ，可以采用如下格式：

```c++
class code{
private:
	 int member1, member2; //定义私有成员
public:
	code(int a,int b) : member1(a),member2(b){} // 初始化
```

可在class外对所构造的函数进行更详细的“刻画” ，格式如下：

类名：：类名（？，？）{？？；} （此时应使用构造函数）

例：clock::Set（int h,int m,int s）{......}

### **6.易错**

1.namespace易打错，注意std以及分号

2.class后面的类包含的内容用{}；圈住。**注意不要漏了分号！**

3.public和private后面加“：”，同时注意靠左

4.注意缩进使程序更易读（Dev一般有默认缩进）

5.流输入与输出中>>和<<容易混淆，可以把cin和cout想像成自己，同时<<跟>>符号右边有一台电脑，符号就不会搞错了

### **7.重载函数**

重载函数是函数的一种特殊形式，c++允许在同一范围中声明几个功能不同的同名函数，但是这些**同名函数的形式参数必须不同（参数的个数，类型）。**这就是重载函数，需要注意的是只有函数返回值类型不同的函数不能作为重载函数。

 例如：

int add(int a, int b) {return a+b;}

float add(float a, float b) {return a+b;}

这是两个函数函数名相同，但参数类型不同的函数。“函数重载”指的是可以有多个同名的函数，因此对名称进行了重载。



##  **C++第二课**-函数重载与类的成员函数重载，默认参数值函数——认识多态



### 1 多态的概念：

* 多态按字面的意思就是“多种状态”。在面向对象语言中，**接口的多种不同的实现方式**即为多态。

* 多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

* 在C++中，多态性表现形式之一是：具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数。

* 从系统实现的角度看，多态性分为静态多态性和动态多态性两类。两者区别在于静态多样性要求在程序编译时就知道调用函数的全部信息，又称为编译时的多态性；动态多态性则不在编译时确定调用的函数，而是在程序运行时才动态确定操作所针对的对象。

* 可以类比为“打”这个字，可以说是“老师打同学”，是击打这个动作；还可以是“我去打酱油”，是舀取的意思；也可以是“打南边来了个喇嘛”，是“从”的意思。“打”即函数名，不同的意思就是不同功能的函数。

 

### 1.2 函数重载:

* C++中允许有多个拥有类似功能的同名函数的存在，但是这些同名的函数的**参数个数**、**类型或顺序**这三个属性当中必须至少有一个与其余的同名函数存在差异。编译器可以通过名称修饰，找到与之相匹配的函数，从而实现不同的功能。这样一来，既减少了函数名的数量，又避免了名字空间的污染，也降低了程序员记忆的难度。需要注意的是只有函数返回值类型不同的函数不能作为重载函数。

  


### 1.3 函数重载的理解：

1.函数重载是一种多态现象

* 多态：相同的行为方式可能导致不同的行为结果，即产生了多种形态行为，即多态。

2.编译原理--重载的函数符号表中生成的名称不一样。例如：

```c++
int sum(int a,int b,int c );

int sum(int a,int b);            

float sum(float a,float b,float c);
```

3.重载函数常用来实现功能类似而所处理的数据类型不同的问题

4.编译器选择最合适的重载函数的过程，称为**重载决策**

 

### 1.4 函数重载的规则：

1.函数名称必须相同。

2.参数列表必须不同（个数不同、类型不同、参数排列顺序不同等至少具有其中一个。允许参数的类型不同，允许参数的个数不同）。

3.函数的返回类型可以相同也可以不相同。

4.仅仅返回类型不同不足以成为函数的重载。

5.构造函数也可以被重载，只要每个构造函数的形参列表是唯一的。不同的构造函数允许建立对象时用不同的方式来初始化数据成员。

 6.引用作为函数参数时注意不同的格式，要与其他格式区分开来。

【重载函数的最佳匹配和歧义**Best matches and ambiguities**
有可能会有多个重载函数能够匹配一个函数调用。例如，下面的四个函数：

```c++
void f(int i); void f(longint li); void f(char *p); void f(double d, int i); 
```

开头的三个函数可以匹配函数调用f(0)。0可以被看做int，long int或char*类的空指针。第四个函数没法匹配，因为它需要两个参数。

当面对多个可选函数时，重载决策根据函数参数类型的隐式转换来排序，找出最匹配的那个。例如，在调用f(0)时，参数0位int类型，当调用：

```c++
void f(char *p); 
```

需要把int转换为char*。当调用：

```c++
void f(long int li); 
```

需要把int转换为long int。而：

```c++
void f(int i); 
```

是非常准确的匹配。准确的匹配永远是最佳选择。

那么，假设：

```c++
void f(int i); 
```

没有被声明。这种情况下，重载决策必须在下面二者中选一个：

```c++
void f(long int li); void f(char *p); 
```

但它们两个不分仲伯，都需要进行类型转换。当重载决策没有办法选出一个最优匹配，那么调用就是不明确的，这会产生一个编译错误。

函数参数顺序不同也作为一种函数重载，注意：void f (int a,double b)与 void f(double a,int b)算是重载，而void f(int a,double b)与 void f(int b,double a)不算是重载

`C++是一门非常高级的语言，可以精确的匹配很多不同数据类型，大大减少了开发者的工作强度。`

关于"//StudybarCommentBegin" 和 "//StudybarCommentEnd" 的说明：后台会把这两行之内的代码自动过滤掉，这样同学们就不用自己注释掉前后缀代码了，简化同学们交有前后缀的题目操作了

注意事项：

C++规定，每个类必须有一个构造函数，没有构造函数就不能创建任何对象。 若未提供一个类的构造函数，则C++提供一个默认的构造函数，该函数是无参构造函数，它不做任何初始化。 只要一个类定义了一个构造函数，C++就不再提供默认的构造函数。即如果为类定义了一个带参数的构造函数，还要无参构造函数，就必须自己定义。

在使用重载函数时，同名函数的功能应当相同或相近，不要用同一函数名去实现完全不相干的功能。

## 1.5 默认参数值功能：

在定义构造函数时，可以给括号内形参赋初值。在构造函数内，如果没有对某些参数进行赋值，那么在实例化后这些参数将获得默认值。但是，一旦这样定义构造函数后，该函数就已经包括了不同形参个数的情况。即不允许再定义产生歧义的函数，否则编译器不知道在调用时该使用哪个函数。

 c++对一般的函数都允许有默认参数值功能。默认参数值一定要从右往左写，如int func(int a, int b=0,int c=0)这就是可以的，如int func(int a=0,int b,int c=0)这就是不可以的。在调用这个函数的时候，如果传入的形参的个数足够，那么就不会赋默认值了。如果少了一个形参，那么最右边一个形参会被赋默认值。少了两个最右边两个就被赋默认值。以此类推。即传入的值从左往右读，默认值从右往左赋。

注：设置默认值时在类外编写函数内容时要只在函数声明中设置默认值，而不在函数编写时二次设置。实例如下：

**编译错误：**

```c++
class A

{

public：A（int a=0，int b=0）;

private：int aa，bb；

};

A:: A（int a=0，int b=0）{aa=a；bb=b；}  
```

**编译正确：**



```c++
class A

{
 
public：A（int a=0，int b=0）;

private：int aa，bb；

};

A:：A（int a，int b）{aa=a；bb=b；}    
```

 默认参数值补充：

（1）C++中可以在函数声明时为参数提供一个默认值，

  当函数调用时没有指定这个参数的值，编译器会自动用默认值代替

```c++
void myPrint(int x = 3)

{

   printf("x:%d", x);

}
```

（2）函数默认参数的规则

  只有参数列表后面部分的参数才可以提供默认参数值

   一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值

 默认参数

```c++
void printAB(int x = 3)

{

	printf("x:%d\n", x);

}
```

 在默认参数规则 ，如果默认参数出现，那么右边的都必须有默认参数

```c++
void printABC(int a, int b, int x = 3, int y=4, int z = 5)

{

    printf("x:%d\n", x);

}

int main62(int argc, char *argv[])

{

    printAB(2);

    printAB();

    system("pause");

    return 0;

}
```



## 1.6 引用：

引用就是给变量起个别名，改变这个别名等同于对其本身做操作；引用变量的主要用途是用作函数的形参。

* 引用只能引用变量，不能引用常量和表达式

* 引用的声明方法：类型标识符 &引用名=目标变量名

* 引用变量和其所指向的变量指向相同的值和内存单元

&符号：指示变量的地址

C++给&符号赋予了另一个含义，将其用来声明引用。

必须在声明引用变量时进行初始化，不可以先声明后赋值

初始化后会一直引用该变量

当声明一个引用后，不可以再使其成为另一个变量的引用

如：

```c++
int a1,a2;

int &b=a1;

int &b=a2; // 这是错误的，引用一旦被使用，不可改变）
```

&前面没有类型是取地址(b=&a;把a的地址赋值给b)

&前面有类型是引用（int & b = a;给a取一个叫做b的别名）

**使用引用的优点——避免拷贝：**

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。举个例子，编写一个函数比较两个string对象的长度，因为string对象可能会非常长，所以我们应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。

​    

**引用和指针的区别：**

**本质上：**

引用是别名；指针是地址。

**具体的：**

①   从现象上看，指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。

② 从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。

③ 从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。

④ 不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。

⑤ 理论上，对于指针的级数没有限制，但是引用只能是一级。如下：

 int ** p1;      // 合法。指向指针的指针

 int *& p2;     // 合法。指向指针的引用

 int &* p3;      // 非法。指向引用的指针是非法的

 int && p4;     // 非法。指向引用的引用是非法的

 注意上述读法是从左到右。

⑥ 指针和引用的自增符号（++）意义不同。指针的自增符号表示指向下一个内存地址，引用的自增符号表示引用的变量加一。

⑦ 引用过程会进行类型检查，指针不会进行类型检查，引用相对来说更加安全。





## 复数类于运算符重载

### **类作为函数的返回值**

当类中成员函数的参数不止一个，且需要同时作为返回值返回时，可用类的形式返回，且在定义返回值类型的时候，返回值类型名应与类名相同（例如想在Cmytime类里面定义一个返回值类型为Cmytime的函数，则定义方式为 Cmytime 函数名() ）

###  **友元函数**

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。A是B的友元不代表B是A的友元。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend 进行声明**

因为友元函数没有this指针，则参数要有三种情况：

1.要访问非static成员时，需要对象做参数。

2.要访问static成员或全局变量时，则不需要对象做参数。

3.如果做参数的对象是全局对象，则不需要对象做参数.可以直接调用友元函数，不需要通过对象或指针。

注意：友元是C++提供的一种破坏数据封装和数据隐藏的机制，为了确保数据的完整性，每次使用友元函数时最好检查一下友元函数是否会改变private或protected内变量的值。

### **运算符重载**

运算符重载是一种形式的C++多态。其格式operator符号(参数){}。例如，operator+()重载为运算符"+"的重载，operator*()为运算符"*"的重载。op必须是有效的C++运算符，不能虚构一个新的符号。一般而言，四则运算的重载函数返回类型仍为给定类（如复数类加法重载运算，返回类型仍是复数类，所以在main函数中可以实现z1=z2+z3的操作），"==""!="返回int。

需要注意的是：**C++规定：“=”、“[ ]”、“( )”、“->” 这四个运算符只能被重载为类的非静态成员函数，而不能被重载为友元函数，这是需要特殊记忆的。**

如果要将运算符重载内容放在类外，写法如下：

```c++
ElementType Cmycomplex::operator+(Cmycomplex &z)
    
  //  {...};
```

（比如说用课堂上的类Cmycomplex并重载+号）

运算符重载是对已有的运算符赋予多重含义

 

### 必要性

C++中预定义的运算符其运算对象只能是基本数据类型，而不适用于用户自定义类型（如类）。

实现机制

定义一个重载运算符的函数，在需要执行被重载的运算符时，把指定的运算表达式转化为对运算符函数的调用（系统自动调用）。也就是说，运算符重载是通过定义函数实现的。运算符重载实质上是函数的重载。

编译系统对重载运算符的选择，遵循函数重载的选择原则（根据实参的类型来确定需要调用的函数）。 

重载运算符的规则如下：

1.C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。

2.C++并非所有运算符都能重载，有一些运算符不能重载。（已于下表给出）

3.重载不能改变运算符运算对象的个数。

4.重载不能改变运算符的优先级和结合性。

5.重载运算符的函数不能有默认参数。

6.重载的运算符必须和用户定义的自定义类型的对象一起使用，至少有一个应为类对象。

 

注：用成员方式重载二元运算符时, 只需要一个右操作参数, 另一个左操作参数由this指针传入，所以，像

Cmycomplex::operator+(Cmycomplex&, Cmycomplex&)

都要改成

Cmycomplex::operator+(Cmycomplex&)

第一个参数默认由左操作数的this指针自动传入到函数中去的.

因此，如果左操作数不是自定义的类的对象，而是int型等其他类型时，不可用成员方式重

载，而应用友元函数重载，这样左操作数的类型就没有限制了。

 

### 下面是可重载的运算符列表：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | ()(函数调用)，->(成员访问)，,(逗号)，[](下标)                |

下面是不可重载的运算符列表：

- .：成员访问运算符
- .*, ->*：成员指针访问运算符
- ::：域运算符
- sizeof：长度运算符
- ?:：条件运算符
- \#： 预处理符号    

（单目运算符是只对一个变量进行操作的运算符，双目运算符是对两个变量进行操作的运算符，三目...）

###  **小数的精度**

头文件：
\#include<iostream>
\#include<iomanip>
using namespace std;

cout<<setiosflags(ios::fixed)<<setprecision(2);

然后再输出实数类型变量即可以保留2位小数输出了，当然你要保留三位小数，setprecision(3)就行。

setprecision是指设置输出精度，当**没有**cout<<setiosflags(ios::fixed)时，输出格式是数据的**有效位数(C++有效位数为六位)**，例如

float a = 123.666;

```
cout<<setprecision(5)<<a;
```

将输出123.67（注意这里，它会四舍五入）。如果setprecision里的参数小于整数位数，将以指数形式输出，例如

```
float a = 123.666;
cout<<setprecision(2)<<a;
```

将输出1.2e+002。

setiosflags(ios::fixed)是指以固定的浮点显示，当setiosflags(ios::fixed)和serprecision(n)两个一起用时就表示保留n位小数输出。这里还要注意，每次输出只要设置一次就行了，因为这两个的作用范围是后续对象，而不是仅对后一个对象起作用。

如果不使用using namespace std;

要写成这个形式： cout<<"("<<std::setprecision(有效数字位数)<<x;

###  **流运算符重载**

可以对<< >>运算符进行重载。

cout是一个ostream对象，能够识别所有的C++基本类型，这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。所以，同样的，它也可以对自己规定的类型进行定义。比如：

```c++
ostream& **operator** << (ostream & out, const ComplexNumber &z)    
    //const的作用：将&z保护起来
{ 
   	out<<"("<<z.x<<"+"<<z.y<<"i"<<")";
 	return out;

}
```

函数返回一个ostream对象，这里定义了一个名为out的ostream对象，并返回out。

out 也可以被我们定义为别的，比如2019out，相应的就改为：

```c++
ostream& **operator** << (ostream & 2019out, const ComplexNumber &z)
{
    2019out<<"("<<z.x<<"+"<<z.y<<"i"<<")";
 	return 2019out;
}
```

 相应的，>>运算符也可以重载

```c++
istream& **operator** >> (istream & in, ComplexNumber &z)
{ 
    in>>z.x>>z.y;
 	return in;
}
```

