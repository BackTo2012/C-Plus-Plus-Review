# C++ const引用、临时变量 引用参数详解



下面小编就为大家带来一篇C++ const引用、临时变量 引用参数详解。小编觉得挺不错的现在就分享给大家，也给大家做个参考。一起跟随小编过来看看吧

**C++引用—临时变量、引用参数和const引用**

如果实参与引用参数不匹配，C++将生成临时变量。如果引用参数是const,则编译器在下面两种情况下生成临时变量：

**实参类型是正确的，但不是左值**

**实参类型不正确，但可以转换为正确的类型**

左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和被解除引用的指针都是左值，非左值包括字面常量和包含多项式的表达式。定义一个函数

```c++
Double refcube(const double& ra)

{
     Returnra*ra*ra;
}


double side = 3.0;

double* pd = &side;

double& rd = side;

long edge = 5L;

double lens[4]={2.3,3.4,4.5,6.7};

double c1 = refcube(side); // ra 是side

double c2 = refcube(lens[2]); // ra是lens[2]

double c3 = refcube(rd);  // ra 是 rd

double c4 = refcube(*pd); // ra 是*pd

double c5 = refcube(edge); // ra 是临时变量

double c6 = refcube(7.0); // ra 是临时变量

double c7 = refcube(side+10.0); // ra 是临时变量
```

参数side lens[2] rd 和*pd都是有名称的、double类型的数据对象，因此可以为其创建引用，而不需要临时变量。但是edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side+10.0的类型都正确，但没有名称，在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，伺候编译器便可以任意将其删除

那么为什么对于常量引用，这种行为是可行的，其他情况下却不行呢？

```c++
Void swapr(int& a,int& b)

{

     Inttemp;

     Temp=a;

     A= b;

     B= temp;

}
```



在早期的C++较宽松的规则下，执行下面的操作将发生什么？

Long a = 3,b = 5;

Swapr(a,b);

这里的类型不匹配，因此编译器将创建两个临时的int变量，将他们初始化为3和5,然后交换临时变量的内容，而a和b保持不变

简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现，解决方法是，禁止创建临时变量，下载的C++标准正是正阳做的、

现在来看refcube()函数，该函数的目的只是使用传递的值，而不是修改他们，因此临时变量不会造成任何不利的影响。反而会使函数在可处理的参数种类方面更通用。因此，如果声明将引用指定为const，C++将在必要时生成临时变量、实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值、

（PS:如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量）

**应尽可能使用const**

使用cosnt可以避免无意总修改数据的编程错误

使用const使函数能够处理const和非const实参，否则将只能接受非const数据

使用const引用使函数能够正确生成并使用临时变量

以上这篇C++ const引用、临时变量 引用参数详解就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。